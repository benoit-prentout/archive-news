name: Gemini Auto-Detect Responder

on:
  issues:
    types: [labeled]

permissions:
  contents: read
  issues: write

jobs:
  auto_respond:
    if: github.event.label.name == 'question-gemini'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: üïµÔ∏è Detect Valid Model & Generate
        id: gemini
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
        run: |
          # 1. R√©cup√©rer la liste de TOUS les mod√®les disponibles pour ta cl√©
          echo ">>> Recherche des mod√®les disponibles..."
          MODELS_JSON=$(curl -s "https://generativelanguage.googleapis.com/v1beta/models?key=$GEMINI_API_KEY")
          
          # 2. Filtrer pour trouver un mod√®le qui accepte "generateContent"
          # On extrait la liste des noms valides via jq
          VALID_MODELS=$(echo "$MODELS_JSON" | jq -r '.models[] | select(.supportedGenerationMethods[]? | contains("generateContent")) | .name')
          
          if [ -z "$VALID_MODELS" ]; then
            echo "‚ùå AUCUN mod√®le compatible trouv√©. V√©rifie ta cl√© API."
            echo "ANSWER=‚ùå Erreur critique : Aucun mod√®le Gemini disponible pour cette cl√©." >> $GITHUB_ENV
            exit 0
          fi

          # 3. Strat√©gie de s√©lection : On pr√©f√®re 1.5 Flash, sinon 1.5 Pro, sinon le premier qui vient
          SELECTED_MODEL=$(echo "$VALID_MODELS" | grep "1.5-flash" | head -n 1)
          
          if [ -z "$SELECTED_MODEL" ]; then
             SELECTED_MODEL=$(echo "$VALID_MODELS" | grep "1.5-pro" | head -n 1)
          fi
          
          if [ -z "$SELECTED_MODEL" ]; then
             SELECTED_MODEL=$(echo "$VALID_MODELS" | head -n 1)
          fi

          echo ">>> ‚úÖ Mod√®le s√©lectionn√© : $SELECTED_MODEL"

          # 4. Pr√©paration du prompt
          jq -n \
            --arg title "$ISSUE_TITLE" \
            --arg body "$ISSUE_BODY" \
            '{
              contents: [{
                parts: [{
                  text: ("Tu es un expert d√©veloppeur. Analyse cette issue GitHub : " + $title + ".\n\nDescription :\n" + $body + "\n\nDonne une solution technique concr√®te et concise.")
                }]
              }]
            }' > payload.json

          # 5. Appel API avec le mod√®le DYNAMIQUE trouv√©
          # Note : SELECTED_MODEL contient d√©j√† le pr√©fixe "models/" (ex: models/gemini-1.5-flash)
          curl -s \
            -H "Content-Type: application/json" \
            -d @payload.json \
            "https://generativelanguage.googleapis.com/v1beta/$SELECTED_MODEL:generateContent?key=$GEMINI_API_KEY" > response.json
          
          # 6. Extraction de la r√©ponse
          ANSWER=$(cat response.json | jq -r '.candidates[0].content.parts[0].text')
          
          # Gestion d'erreur ultime
          if [ "$ANSWER" == "null" ]; then
             ERR=$(cat response.json | jq -r '.error.message')
             ANSWER="‚ùå Erreur avec le mod√®le $SELECTED_MODEL : $ERR"
          fi

          # Passage de la variable √† l'√©tape suivante (multiligne)
          echo "ANSWER<<EOF" >> $GITHUB_ENV
          echo "$ANSWER" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "USED_MODEL=$SELECTED_MODEL" >> $GITHUB_ENV

      - name: Post Comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          AI_RESPONSE: ${{ env.ANSWER }}
          MODEL_NAME: ${{ env.USED_MODEL }}
        run: |
          gh issue comment "$ISSUE_NUMBER" --body "ü§ñ **R√©ponse de Gemini** (via $MODEL_NAME) :
          
          $AI_RESPONSE"
